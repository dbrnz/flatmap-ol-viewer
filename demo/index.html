  <head>
    <title>background-map.png</title>
    <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

    <!-- OpenLayers and Proj4js -->
    <link rel="stylesheet" href="https://cdn.rawgit.com/openlayers/openlayers.github.io/master/en/v5.3.0/css/ol.css" type="text/css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.5.0/proj4.js"></script>
    <script src="https://cdn.rawgit.com/openlayers/openlayers.github.io/master/en/v5.3.0/build/ol.js"></script>

    <!-- Layer switcher -->
    <link rel="stylesheet" href="https://unpkg.com/ol-layerswitcher@3.0.0/src/ol-layerswitcher.css" />
    <script src="https://unpkg.com/ol-layerswitcher@3.0.0"></script>

    <!-- Context menus -->
    <link href="/static/css/ol-contextmenu.min.css" rel="stylesheet" type="text/css">
    <script src="https://cdn.jsdelivr.net/npm/ol3-contextmenu"></script>

    <!-- Tiled GeoJSON -->
    <!-- <script src="https://mapbox.github.io/geojson-vt/geojson-vt-dev.js"></script> -->
    <script src="/static/scripts/geojson-vt-dev.js"></script>

    <style type="text/css">
      html, body {
        height: 100%;
        padding: 0;
        margin: 0;
        font-family: sans-serif;
        font-size: small;
        overflow: hidden;
        font: 10pt "Helvetica Neue", Arial, Helvetica, sans-serif;
      }
      .map {
        position: absolute;
        top: 1%;
        left: 1%;
        width: 48.5%;
        height: 98%;
        border: 1px solid black;
        font: 10pt "Helvetica Neue", Arial, Helvetica, sans-serif;
      }
      #map2 {
        left: 50.5%;
      }
      .popover-content {
        min-width: 180px;
      }
    </style>
    <style>
      .ol-popup {
        position: absolute;
        background-color: white;
        -webkit-filter: drop-shadow(0 1px 4px rgba(0,0,0,0.2));
        filter: drop-shadow(0 1px 4px rgba(0,0,0,0.2));
        padding: 15px;
        border-radius: 10px;
        border: 1px solid #cccccc;
        bottom: 12px;
        left: -50px;
        min-width: 280px;
      }
      .ol-popup:after, .ol-popup:before {
        top: 100%;
        border: solid transparent;
        content: " ";
        height: 0;
        width: 0;
        position: absolute;
        pointer-events: none;
      }
      .ol-popup:after {
        border-top-color: white;
        border-width: 10px;
        left: 48px;
        margin-left: -10px;
      }
      .ol-popup:before {
        border-top-color: #cccccc;
        border-width: 11px;
        left: 48px;
        margin-left: -11px;
      }
      .ol-popup-closer {
        text-decoration: none;
        position: absolute;
        top: 2px;
        right: 8px;
      }
      .ol-popup-closer:after {
        content: "âœ–";
      }
    </style>
    <script>
      // From our SVG coordinates to PNG pixels
      const imageOffset = 200;
      const PNGscale = 25;

      let map = null;

      const imageExtent = [0, 0, 10000, 18000];

      const startResolution = 128;
      const resolutions = new Array(22);
      for (let i = 0, ii = resolutions.length; i < ii; ++i) {
        resolutions[i] = startResolution / Math.pow(2, i);
      }

      const tilegrid = new ol.tilegrid.TileGrid({
        origin: [0, 0],
        extent: imageExtent,
        resolutions: resolutions
      });

      // Or use say +proj=utm +zone=60 +south ???
      const projection = new ol.proj.Projection({
        code: 'user:1000',
        units: 'm',
        worldExtent: imageExtent
      });
      ol.proj.addProjection(projection);

      function newTileLayer(name)
      {
        return new ol.layer.Tile({
          title: name[0].toUpperCase() + name.slice(1),
          source: new ol.source.TileImage({
            tileGrid: tilegrid,
            tileUrlFunction: (...args) => getLayerURL(name, ...args)
          })
        });
      }

      function getLayerURL(layer, coord, ratio, proj)
      {
        return `${window.location.href}/tiles/${layer}/${coord[0]}/${coord[1]}/${coord[2]}`;
      }

      function init()
      {
        const view1 =  new ol.View({
            projection: 'user:1000',
            resolutions: resolutions,
            center: [5000, 9000],
            zoom: 0,
            maxZoom: 7
          });

        const circleFeature = new ol.Feature(new ol.geom.Circle([9050, 15150], 600));

        const select = new ol.interaction.Select({filter: (feature, layer) => {
          return (feature === circleFeature);
        }});

        const translate = new ol.interaction.Translate({
          features: select.getFeatures()
        });

        map = new ol.Map({
          // ??? renderer: 'webgl',  // ???????
          interactions: ol.interaction.defaults().extend([select]), //, translate]),
          layers: [
            new ol.layer.Tile({
              title: 'Body',
              type: 'base',
              source: new ol.source.TileImage({
                tileGrid: tilegrid,
                tileUrlFunction: (...args) => getLayerURL('head', ...args),
                tileLoadFunction: (tile, src) => {
                  const tileCoord = tile.getTileCoord();
                  console.log(`Request image tile at ${tileCoord}`);
                  tile.getImage().src = src;
                }
              })
            }),
            new ol.layer.Tile({
              title: 'Grid',
              //visible: false,
              source: new ol.source.TileDebug({
                tileGrid: tilegrid,
                projection: 'user:1000'
              })
            })
          ],
          target: 'map1',
          view: view1,
          loadTilesWhileInteracting: true,
          loadTilesWhileAnimating: true
        });

        // map.addLayer(newTileLayer('cardiovascular'));
        // map.addLayer(newTileLayer('brownfat'));
        // map.addLayer(newTileLayer('respiratory'));
        // map.addLayer(newTileLayer('digestive'));
        // map.addLayer(newTileLayer('exocrine'));
        // map.addLayer(newTileLayer('endocrine'));
        // map.addLayer(newTileLayer('urinary'));
        // map.addLayer(newTileLayer('reproductive'));
        // map.addLayer(newTileLayer('spine'));
//      //   map.addLayer(newTileLayer('ganglia'));
        // map.addLayer(newTileLayer('neural'));

        /**
         * Elements that make up the popup.
         */
        const container = document.getElementById('popup');
        const content = document.getElementById('popup-content');
        const closer = document.getElementById('popup-closer');

        /**
         * Create an overlay to anchor the popup to the map
         */
        const overlay = new ol.Overlay({
          element: container,
          autoPan: true,
          autoPanAnimation: {
            duration: 250
          }
        });

        /**
         * Add a click handler to hide the popup
         * @return {boolean} Don't follow the href
         */
        closer.onclick = function() {
          overlay.setPosition(undefined);
          closer.blur();
          return false;
        };

        map.addOverlay(overlay);

        const featureJSON = {
          "type": "FeatureCollection",
          "features": [
/*            { "type": "Feature",
              "geometry": {
                "type": "Polygon",
                "coordinates": [[
                  [ 2000, 7000],
                  [ 4000, 7000],
                  [ 4000, 9000],
                  [ 2000, 7000]
                ]]
              },
              "properties": {
                "name": "Triangle!"
              }
            },
*/
            pointFeature([PNGscale*(562-imageOffset), PNGscale*618], 'xii'),
            pointFeature([PNGscale*(562-imageOffset), PNGscale*605], 'ix'),
            pointFeature([PNGscale*(562-imageOffset), PNGscale*594], 'x')
          ]
        };

        function pointFeature(coordinates, name)
        {
          return {
            type: "Feature",
            geometry: {
              type: "Point",
              coordinates: coordinates
            },
            properties: {
              name: name
            }
          };
        }

/*
        const vectorSource = new ol.source.Vector({  dataProjection: ??
          features: (new ol.format.GeoJSON()).readFeatures(featureJSON)
        });
*/

        /* GeoJSON */

        const vectorSource = new ol.source.Vector({
          format: new ol.format.GeoJSON({dataProjection: 'user:1000'}),
          url: `${window.location.href}/json/features`
        });

        vectorSource.addFeature(circleFeature);

        const style = new ol.style.Style({
          fill: new ol.style.Fill({color: 'pink'}),
          text: new ol.style.Text({
            fill: new ol.style.Fill({color: 'green'})
          })
        });

        const labels = new ol.layer.Vector({
          title: "Labels",
          source: vectorSource,
          style: (feature, resolution) => {
            //console.log(`style for ${feature.get('name')} at RES: ${resolution}`);
            const styleText = style.getText();
            const fontSize = 4*Math.sqrt(startResolution/resolution);
            styleText.setFont(`bold ${fontSize}px "Open Sans", "Arial Unicode MS", "sans-serif"`);
            styleText.setText(feature.get('name'));
            return style;
          }
        });

        map.addLayer(labels);

        const labeledGanglia = new ol.layer.Group({title: "Ganglia",
                                                   layers: [labels, newTileLayer('ganglia')]
                                                 });
        // map.addLayer(labeledGanglia);


        /* TopoJSON */
/*
        const topologySource = new ol.source.Vector({
          format: new ol.format.TopoJSON({dataProjection: 'user:1000'}),
          url: `${window.location.href}/json/topology`
        });
*/
        /* Vector Tiles */

        /**
         * Map GeoJSON features to Mapbox vector tiles
         *
         * @param      {<type>}  key     The key
         * @param      {<type>}  value   The value
         * @return     {Object}  { description_of_the_return_value }
         */
        function replacer(key, value)
        {
          if (value.geometry) {
            var type;
            var rawType = value.type;
            var geometry = value.geometry;

            if (rawType === 1) {
              type = 'MultiPoint';
              if (geometry.length == 1) {
                type = 'Point';
                geometry = geometry[0];
              }
            } else if (rawType === 2) {
              type = 'MultiLineString';
              if (geometry.length == 1) {
                type = 'LineString';
                geometry = geometry[0];
              }
            } else if (rawType === 3) {
              type = 'Polygon';
              if (geometry.length > 1) {
                type = 'MultiPolygon';
                geometry = [geometry];
              }
            }

            return {
              'type': 'Feature',
              'geometry': {
                'type': type,
                'coordinates': geometry
              },
              'properties': value.tags
            };
          } else {
            return value;
          }
        }

        const tilePixels = new ol.proj.Projection({
          code: 'TILE_PIXELS',
          units: 'tile-pixels'
        });

        function normaliseCoordinates(coords)
        {
          return [(coords[0]/10000) + 0.5, coords[1]/18000];  /* */
        }

        const url = `${window.location.href}/json/triangle`;
        fetch(url).then(function(response) {
          return response.json();
        }).then(function(json) {
          const tileIndex = geojsonvt(json, {
            pointNormaliseFunction: normaliseCoordinates,
            pointTransformFunction: (x, y, extent, z2, tx, ty) => {
              console.log('Transform:', x, y, extent, z2, tx, ty)
              return [
                Math.round(extent * (x * z2 - tx)),
                Math.round(extent * (y * z2 - ty))
              ];
            },
            extent: 256,
            buffer: 16,
/*
            maxZoom: 7,
            indexMaxZoom: 7,
            indexMaxPoints: 0,
*/
            debug: 0
          });
          const vectorSource = new ol.source.VectorTile({
            format: new ol.format.GeoJSON(), // {dataProjection: 'user:1000'}),
            tileGrid: tilegrid,
            tileLoadFunction: function(tile) {
              const format = tile.getFormat();
              const tileCoord = tile.getTileCoord();
              const data = tileIndex.getTile(tileCoord[0], tileCoord[1], tileCoord[2]);
console.log(`Request vector tile at ${tileCoord}, tiles=${data}`);
              const features = format.readFeatures(
                JSON.stringify({
                  type: 'FeatureCollection',
                  features: data ? data.features : []
                }, replacer));
              tile.setLoader(function() {
                tile.setFeatures(features);
                tile.setProjection(tilePixels);  // 'user:1000'
              });
            },
            url: 'data:' // arbitrary url, we don't use it in the tileLoadFunction
          });
          const vectorLayer = new ol.layer.VectorTile({
            title: "Vector tiles",
            source: vectorSource,
            style: new ol.style.Style({
              stroke: new ol.style.Stroke({
                color: '#f00',
                width: 20
              }),
              fill: new ol.style.Fill({color: 'blue'})
            })
          });

          map.addLayer(vectorLayer);
        });

        /* Overview map */

        map.addControl(new ol.control.OverviewMap({
            //collapsed: false,
            view: new ol.View({
              projection: 'user:1000',
              resolutions: resolutions,
              center: [5000, 9000],
              zoom: 3,
              maxZoom: 7
            })
          })
        );


        // Add a layer switcher

        const layerSwitcher = new ol.control.LayerSwitcher();
        map.addControl(layerSwitcher);

        const view2 =  new ol.View({
            projection: 'user:1000',
            resolutions: resolutions,
            center: [5000, 9000],
            zoom: 4,
            maxZoom: 6
          });

//        map2 = new ol.WebGLMap({
        map2 = new ol.Map({
          interactions: ol.interaction.defaults().extend([select, translate]),
          view: view1,
          layers: [
            new ol.layer.Tile({
              title: 'Cardiovascular',
              type: 'base',
              source: new ol.source.TileImage({
                tileGrid: tilegrid,
                tileUrlFunction: (...args) => getLayerURL('cardiovascular', ...args)
              })
            })
          ],
          target: 'map2',
          loadTilesWhileInteracting: true,
          loadTilesWhileAnimating: true
        });
        map2.addLayer(newTileLayer('spine'));
        map2.addLayer(newTileLayer('ganglia'));
        map2.addLayer(newTileLayer('neural'));

        map2.addLayer(labels);

        const layerSwitcher2 = new ol.control.LayerSwitcher();
        map2.addControl(layerSwitcher2);

        /**
         * Add a click handler to the map to render the popup.
         */
        map.on('singleclick', function(evt) {
          const coordinate = evt.coordinate;
          const coords = `(${coordinate[0]}, ${coordinate[1]})`;
          //content.innerHTML = '<p>Clicked at <code>' + coords + '</code></p>';
          content.innerHTML = '<form>Prompt: <input type="text" id="xx"/><input type="button" value="XX"/></form>';
          overlay.setPosition(coordinate);
        });


        /* Context menu */

        function actionClick(action, evt)
        {
          alert(`Action ${action}...`)
        }

        const contextmenu = new ContextMenu({
          width: 170,
          defaultItems: true, // defaultItems are (for now) Zoom In/Zoom Out
          items: [
            {
              text: 'Some Actions',
              items: [{ // <== this is a submenu
                text: 'Action 1',
                callback: (...args) => actionClick('1', ...args)
              }, {
                text: 'Other action',
                callback: (...args) => actionClick('2', ...args)
              }]
            }, {
              text: 'Add a Marker',
              icon: '/static/images/marker.png',
              callback: (...args) => actionClick('3', ...args)
            },
            '-' // this is a separator
          ]
        });
        contextmenu.on('open', function (evt) {
          setTimeout(() => contextmenu.close(), 5000);
        });
        map.addControl(contextmenu);
      }
    </script>
  </head>
  <body onload="init()">
    <div id="map1" class="map"></div>
    <div id="map2" class="map"></div>
    <div id="popup" class="ol-popup">
      <a href="#" id="popup-closer" class="ol-popup-closer"></a>
      <div id="popup-content"></div>
    </div>
  </body>
</html>
